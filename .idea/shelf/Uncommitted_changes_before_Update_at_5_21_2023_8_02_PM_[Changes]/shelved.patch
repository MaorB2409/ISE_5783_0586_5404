Index: src/scene/Scene.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package scene;\r\n\r\nimport lighting.AmbientLight;\r\nimport geometries.Geometries;\r\n//import lighting.Light;\r\nimport lighting.LightSource;\r\nimport primitives.Color;\r\nimport primitives.Point;\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\npublic class Scene {\r\n\r\n    private final String name;\r\n    private final Color background;\r\n    private final Geometries geometries;\r\n    private List<LightSource> lights=new LinkedList<>();\r\n    private AmbientLight ambientLight;\r\n\r\n    private Scene(SceneBuilder builder) {\r\n        name = builder.name;\r\n        background = builder.background;\r\n        ambientLight = builder.ambientLight;\r\n        geometries = builder.geometries;\r\n        lights = builder.lights;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public Color getBackground() {\r\n        return background;\r\n    }\r\n\r\n    public AmbientLight getAmbientLight() {\r\n        return ambientLight;\r\n    }\r\n\r\n    public Scene setAmbientLight(AmbientLight ambientLight) {\r\n        this.ambientLight = ambientLight;\r\n        return this;\r\n    }\r\n\r\n    public Geometries getGeometries() {\r\n        return geometries;\r\n    }\r\n\r\n    public List<LightSource> getLights() {\r\n        return lights;\r\n    }\r\n\r\n    public static class SceneBuilder {\r\n\r\n        private final String name;\r\n        private List<LightSource> lights = new LinkedList<>();\r\n        private Color background = Color.BLACK;\r\n        private AmbientLight ambientLight = new AmbientLight();\r\n        private Geometries geometries = new Geometries();\r\n\r\n        public SceneBuilder(String name) {\r\n            this.name = name;\r\n        }\r\n\r\n        public SceneBuilder setBackground(Color background) {\r\n            this.background = background;\r\n            return this;\r\n        }\r\n\r\n        public SceneBuilder setLights(List<LightSource> lights) {\r\n            this.lights = lights;\r\n            return this;\r\n        }\r\n\r\n        public SceneBuilder setAmbientLight(AmbientLight ambientLight) {\r\n            this.ambientLight = ambientLight;\r\n            return this;\r\n        }\r\n\r\n        public SceneBuilder setGeometries(Geometries geometries) {\r\n            this.geometries = geometries;\r\n            return this;\r\n        }\r\n\r\n        public Scene build() {\r\n            //            validateObject(scene);\r\n            return new Scene(this);\r\n        }\r\n\r\n        private void validateObject(Scene scene) {\r\n            //nothing to do\r\n        }\r\n\r\n        public SceneBuilder readXmlFile(String filename) {\r\n            //to do\r\n            return this;\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/scene/Scene.java b/src/scene/Scene.java
--- a/src/scene/Scene.java	(revision 5f2d62ab7c15a61ddcdf70a4c4164443f7040c90)
+++ b/src/scene/Scene.java	(date 1684176494545)
@@ -13,8 +13,8 @@
 public class Scene {
 
     private final String name;
-    private final Color background;
-    private final Geometries geometries;
+    private Color background;
+    private Geometries geometries;
     private List<LightSource> lights=new LinkedList<>();
     private AmbientLight ambientLight;
 
@@ -51,6 +51,14 @@
         return lights;
     }
 
+    public void setBackground(Color background) {
+        this.background = background;
+    }
+
+    public void setGeometries(Geometries geometries) {
+        this.geometries = geometries;
+    }
+
     public static class SceneBuilder {
 
         private final String name;
Index: src/renderer/RayTracerBasic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package renderer;\r\n\r\nimport geometries.Intersectable;\r\nimport lighting.LightSource;\r\nimport primitives.*;\r\nimport scene.Scene;\r\n\r\nimport java.util.List;\r\n\r\nimport static primitives.Util.alignZero;\r\n\r\n/**\r\n * A class that inherits from RayTracerBase to trace rays in a scene\r\n */\r\npublic class RayTracerBasic extends  RayTracerBase{\r\n    /**\r\n     * size of moving amount for the rays of shadowing\r\n     */\r\n    private static final double DELTA = 0.1;\r\n    /**\r\n     * the max number of times that the recursion is going to happen.\r\n     */\r\n    private static final int MAX_CALC_COLOR_LEVEL = 10;\r\n    /**\r\n     * the min difference that the recursion creates and makes it useless.\r\n     */\r\n    private static final double MIN_CALC_COLOR_K = 0.001;\r\n    /**\r\n     * the initial value of k factor\r\n     */\r\n    private static final double INITIAL_K = 1.0;\r\n\r\n    /**\r\n     * RayTracerBasic Constructor.\r\n     * @param scene the scene we trace rays in.\r\n     */\r\n    public RayTracerBasic(Scene scene){\r\n        super(scene);\r\n    }\r\n\r\n    /**\r\n     * tracing the ray and returns the color that the pixel needs to be painted with.\r\n     *\r\n     * @param ray the ray we need to get the color for.\r\n     * @return the color of te pixel.\r\n     */\r\n    @Override\r\n    public Color traceRay(Ray ray) {\r\n        Intersectable.GeoPoint closestIntersection = findClosestIntersection(ray);\r\n        return closestIntersection == null ? scene.getBackground() : calcColor(closestIntersection, ray);\r\n    }\r\n    /**\r\n     * calculate the color that needed to be returned from the pixel.\r\n     *\r\n     * @param gp  the point to calculate the color for.\r\n     * @param ray the ray to pass to the function that summarise all the effects of the light sources.\r\n     * @return the color to paint the pixel.\r\n     */\r\n    private Color calcColor(Intersectable.GeoPoint gp, Ray ray) {\r\n        return scene.getAmbientLight().getIntensity()\r\n                .add(calcColor(gp, ray, MAX_CALC_COLOR_LEVEL, new Double3(INITIAL_K)));\r\n    }\r\n\r\n    /**\r\n     * the entrance function to the recursive process of calculating the reflective effect and refractive effect.\r\n     *\r\n     * @param gp    the point of intersection that need the color calculation.\r\n     * @param ray   the ray from the camera to that point.\r\n     * @param level the remaining number of times to do the recursion.\r\n     * @param k     the level of insignificance for the k.\r\n     * @return the color of the pixel with all the refractions and reflections.\r\n     */\r\n    private Color calcColor(Intersectable.GeoPoint gp, Ray ray, int level, Double3 k) {\r\n        Color color = calcLocalEffects(gp, ray, k);\r\n        return level == 1 ? color : color.add(calcGlobalEffects(gp, ray, level, k));\r\n    }\r\n\r\n    /**\r\n     * calculating a global effect color\r\n     *\r\n     * @param ray   the ray that intersects with the geometry.\r\n     * @param level the remaining number of times to do the recursion.\r\n     * @param k     the level of insignificance for the k.\r\n     * @param kx    the attenuation factor of reflection or transparency\r\n     * @return the calculated color.\r\n     */\r\n    private Color calcGlobalEffects(Ray ray, int level, Double3 k, Double3 kx) {\r\n        Double3 kkx = kx.product(k);\r\n        //calculate the reflected ray, and the color contribution to the point.\r\n        Intersectable.GeoPoint gp = findClosestIntersection(ray);\r\n        return (gp == null || kkx.lowerThan(MIN_CALC_COLOR_K)) ? Color.BLACK\r\n                : calcColor(gp, ray, level - 1, kkx).scale(kx);\r\n    }\r\n\r\n    /**\r\n     * calculating the color in the global scene, tells what more points we need to\r\n     * check for the color calculations.\r\n     *\r\n     * @param gp    the point of the intersection.\r\n     * @param ray   the ray that intersects with the geometry.\r\n     * @param level the remaining number of times to do the recursion.\r\n     * @param k     the level of insignificance for the k.\r\n     * @return the calculated color.\r\n     */\r\n    private Color calcGlobalEffects(Intersectable.GeoPoint gp, Ray ray, int level, Double3 k) {\r\n        Vector v = ray.getDir();\r\n        Vector normal = gp.geometry.getNormal(gp.point);\r\n        Material material = gp.geometry.getMaterial();\r\n\r\n        Ray reflectedRay = constructReflectedRay(normal, gp.point, v);\r\n        Ray refractedRay = constructRefractedRay(normal, gp.point, v);\r\n        return calcGlobalEffects(reflectedRay, level, k, material.kR)\r\n                .add(calcGlobalEffects(refractedRay, level, k, material.kT));\r\n    }\r\n\r\n    /**\r\n     * The method checks whether there is any object shading the light source from a\r\n     * point\r\n     *\r\n     * @param gp the point with its geometry\r\n     * @param lightSource light source\r\n     * @param l  direction from light to the point\r\n     * @param n normal vector to the surface of gp\r\n     * @param nv dotproduct between n and ray direction\r\n     * @return accumulated transparency attenuation factor\r\n     */\r\n\r\n    private boolean unshaded(Intersectable.GeoPoint gp, LightSource lightSource, Vector l, Vector n, double nv) {\r\n\r\n        Vector lightDirection = l.scale(-1); // from point to light source\r\n        double nl = n.dotProduct(lightDirection);\r\n\r\n        Vector delta = n.scale(nl > 0 ? DELTA : -DELTA);\r\n        Point pointRay = gp.point.add(delta);\r\n        Ray lightRay = new Ray(pointRay, lightDirection);\r\n\r\n        double maxdistance = lightSource.getDistance(gp.point);\r\n        List<Intersectable.GeoPoint> intersections = scene.getGeometries().findGeoIntersections(lightRay,maxdistance);\r\n\r\n        if (intersections == null){\r\n            return true;\r\n        }\r\n\r\n        for (var item : intersections){\r\n            if (item.geometry.getMaterial().getKt().lowerThan(MIN_CALC_COLOR_K)){\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n    /**\r\n     * Calculating the local lighting effects of different light sources\r\n     *\r\n     * @param intersection the intersection point of the ray parameter with the geometric body.\r\n     *                     This method calculate the light intensity at this point.\r\n     * @param ray          the ray that intersects the geometric body\r\n     * @param k            the level of insignificance for the k.\r\n     * @return Color calculated by the light sources\r\n     */\r\n    private Color calcLocalEffects(Intersectable.GeoPoint intersection, Ray ray, Double3 k) {\r\n        // Getting the emission of the geometric body\r\n        Color color = intersection.geometry.getEmission();\r\n\r\n        Vector v = ray.getDir();//direction of the ray\r\n        Vector n = intersection.geometry.getNormal(intersection.point);//normal to the geometric body in the intersection point\r\n\r\n        //if the ray and the normal in the intersection point\r\n        //orthogonal to each other, return just the emission.\r\n        double nv = alignZero(n.dotProduct(v));\r\n        if (nv == 0) return color;\r\n\r\n        Material material = intersection.geometry.getMaterial();//the material of the geometric body\r\n\r\n        //go through all the light sources and calculate their\r\n        //intersection at the point\r\n        for (LightSource lightSource : scene.getLights()) {\r\n            Vector l = lightSource.getL(intersection.point);\r\n            double nl = alignZero(n.dotProduct(l));\r\n            //Check the angle to decide whether\r\n            //to add the effect of the other light sources\r\n            if (nl * nv > 0) { // sign(nl) == sing(nv)\r\n                Double3 ktr = transparency(intersection, l, n, lightSource);\r\n                //Here we deal with the transparency of the objects\r\n                if (unshaded(intersection,lightSource,l,n,nv)) {//!ktr.product(k).lowerThan(MIN_CALC_COLOR_K)\r\n                    Color iL = lightSource.getIntensity(intersection.point).scale(ktr);\r\n                    color = color.add( //\r\n                            iL.scale(calcDiffusive(material, nl)//diffusive effect\r\n                                    .add(calcSpecular(material, n, l, nl, v))));//specular effect\r\n                }\r\n            }\r\n        }\r\n        return color;\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculates the diffusive effect\r\n     *\r\n     * @param material material of the geometric object\r\n     * @param nl       the dot product of the light source ray direction and the normal to the geometric object at the point\r\n     * @return the diffusive effect expressed by Double3 object\r\n     */\r\n    private Double3 calcDiffusive(Material material, double nl) {\r\n        return material.kD.scale(nl > 0 ? nl : -nl);\r\n    }\r\n\r\n    /**\r\n     * Calculates the specular effect\r\n     *\r\n     * @param material material of the geometric object\r\n     * @param n        the normal to the geometric object at the point\r\n     * @param l        the ray of the light source\r\n     * @param nl       the dot product of the light source ray direction and the normal to the geometric object at the point\r\n     * @param v        the direction of the camera ray\r\n     * @return the specular effect expressed by Double3 object\r\n     */\r\n    private Double3 calcSpecular(Material material, Vector n, Vector l, double nl, Vector v) {\r\n        //the reflection of the light source vector (l)\r\n        Vector r = l.subtract(n.scale(2 * nl));\r\n        double minusVR = alignZero(-v.dotProduct(r));\r\n        if (minusVR <= 0) return Double3.ZERO;\r\n\r\n        //Calculation of the effect according to phong model\r\n        return material.kS.scale(Math.pow(minusVR, material.nShininess));\r\n    }\r\n    /**\r\n     * Determining how much light reach a certain point, blocked by other objects\r\n     *\r\n     * @param gp          the point we want to calculate the transparency for\r\n     * @param l           vector from the light source\r\n     * @param n           normal to the point\r\n     * @param lightSource the light source\r\n     * @return the transparency of the point\r\n     */\r\n    private Double3 transparency(Intersectable.GeoPoint gp, Vector l, Vector n, LightSource lightSource) {\r\n        Vector lightDirection = l.scale(-1); // from point to light source\r\n        //We make sure to move the object by DELTA\r\n        //int the correct direction\r\n        //Create a new ray to check shadiness\r\n        Ray lightRay = new Ray(gp.point, lightDirection, n);\r\n\r\n        Double3 ktr = Double3.ONE;\r\n        //Find if any geometric object blocks the light\r\n        List<Intersectable.GeoPoint> intersections = scene.getGeometries().findGeoIntersections(lightRay, lightSource.getDistance(lightRay.getP0()));\r\n        if (intersections == null)\r\n            return ktr;\r\n        //For every geometric object in the list, scale by its transparency coefficient\r\n        for (var geoPoint : intersections) {\r\n            ktr = ktr.product(geoPoint.geometry.getMaterial().kT);\r\n            if (ktr.lowerThan(MIN_CALC_COLOR_K)) return Double3.ZERO;\r\n        }\r\n        return ktr;\r\n    }\r\n\r\n//    /**\r\n//     * The method checks whether there is any object shading the light source from a\r\n//     * point\r\n//     *\r\n//     * @param gp the point with its geometry\r\n//     * @param lightSource light source\r\n//     * @param l  direction from light to the point\r\n//     * @param n normal vector from the surface towards the geometry\r\n//     *\r\n//     * @return accumulated transparency attenuation factor\r\n//     */\r\n//\r\n//    private Double3 transparency(LightSource lightSource, Vector l, Vector n, Intersectable.GeoPoint gp) {\r\n//        // Pay attention to your method of distance screening\r\n//        Vector lightDirection = l.scale(-1); // from point to light source\r\n//        Point point = gp.point;\r\n//        Ray lightRay = new Ray(point, n, lightDirection);\r\n//\r\n//        //double maxdistance = lightSource.getDistance(point);\r\n//        List<Intersectable.GeoPoint> intersections = scene.getGeometries().findGeoIntersections(lightRay);\r\n//\r\n//        if (intersections == null)\r\n//            return Double3.ONE;\r\n//\r\n//        Double3 ktr = Double3.ONE;\r\n////        loop over intersections and for each intersection which is closer to the\r\n////        point than the light source multiply ktr by \uD835\uDC8C\uD835\uDC7B of its geometry.\r\n////        Performance:\r\n////        if you get close to 0 ‚Äìit‚Äôs time to get out( return 0)\r\n//        for (var geo : intersections) {\r\n//            ktr = ktr.product(geo.geometry.getMaterial().getKt());\r\n//            if (ktr.lowerThan(MIN_CALC_COLOR_K)) {\r\n//                return Double3.ZERO;\r\n//            }\r\n//        }\r\n//        return ktr;\r\n//    }\r\n\r\n\r\n    /**\r\n     * the function calculate the reflected ray.\r\n     *\r\n     * @param normal          the normal vector.\r\n     * @param intersection    the in intersection point.\r\n     * @param incomeRayVector the income vector ray,\r\n     * @return the reflected ray.\r\n     */\r\n    private Ray constructReflectedRay(Vector normal, Point intersection, Vector incomeRayVector) {\r\n        double scale = -2 * incomeRayVector.dotProduct(normal);\r\n        return new Ray(intersection, incomeRayVector.add(normal.scale(scale)), normal);\r\n    }\r\n\r\n    /**\r\n     * return ray in the same direction but starts in the intersection point.\r\n     *\r\n     * @param normal          the normal vector.\r\n     * @param intersection    the intersection point.\r\n     * @param incomeRayVector the income vector.\r\n     * @return the fractured ray.\r\n     */\r\n    private Ray constructRefractedRay(Vector normal, Point intersection, Vector incomeRayVector) {\r\n        return new Ray(intersection, incomeRayVector, normal);\r\n    }\r\n\r\n    /**\r\n     * finds the closest intersection GeoPoint to the base of the ray\r\n     *\r\n     * @param ray the ray that we find intersection from\r\n     * @return the closest intersection GeoPoint\r\n     */\r\n    private Intersectable.GeoPoint findClosestIntersection(Ray ray) {\r\n        List<Intersectable.GeoPoint> intersections = scene.getGeometries().findGeoIntersections(ray);\r\n        if (intersections == null) {\r\n            return null;\r\n        }\r\n        return ray.findClosestGeoPoint(intersections);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/renderer/RayTracerBasic.java b/src/renderer/RayTracerBasic.java
--- a/src/renderer/RayTracerBasic.java	(revision 5f2d62ab7c15a61ddcdf70a4c4164443f7040c90)
+++ b/src/renderer/RayTracerBasic.java	(date 1684093387333)
@@ -46,8 +46,12 @@
      */
     @Override
     public Color traceRay(Ray ray) {
-        Intersectable.GeoPoint closestIntersection = findClosestIntersection(ray);
-        return closestIntersection == null ? scene.getBackground() : calcColor(closestIntersection, ray);
+        Intersectable.GeoPoint closestPoint = findClosestIntersection(ray);
+        if (closestPoint == null) {
+            return scene.getBackground();
+        }
+        return calcColor(closestPoint, ray);
+
     }
     /**
      * calculate the color that needed to be returned from the pixel.
@@ -253,44 +257,6 @@
         return ktr;
     }
 
-//    /**
-//     * The method checks whether there is any object shading the light source from a
-//     * point
-//     *
-//     * @param gp the point with its geometry
-//     * @param lightSource light source
-//     * @param l  direction from light to the point
-//     * @param n normal vector from the surface towards the geometry
-//     *
-//     * @return accumulated transparency attenuation factor
-//     */
-//
-//    private Double3 transparency(LightSource lightSource, Vector l, Vector n, Intersectable.GeoPoint gp) {
-//        // Pay attention to your method of distance screening
-//        Vector lightDirection = l.scale(-1); // from point to light source
-//        Point point = gp.point;
-//        Ray lightRay = new Ray(point, n, lightDirection);
-//
-//        //double maxdistance = lightSource.getDistance(point);
-//        List<Intersectable.GeoPoint> intersections = scene.getGeometries().findGeoIntersections(lightRay);
-//
-//        if (intersections == null)
-//            return Double3.ONE;
-//
-//        Double3 ktr = Double3.ONE;
-////        loop over intersections and for each intersection which is closer to the
-////        point than the light source multiply ktr by ùíåùëª of its geometry.
-////        Performance:
-////        if you get close to 0 ‚Äìit‚Äôs time to get out( return 0)
-//        for (var geo : intersections) {
-//            ktr = ktr.product(geo.geometry.getMaterial().getKt());
-//            if (ktr.lowerThan(MIN_CALC_COLOR_K)) {
-//                return Double3.ZERO;
-//            }
-//        }
-//        return ktr;
-//    }
-
 
     /**
      * the function calculate the reflected ray.
Index: unitTests/renderer/ReflectionRefractionTests.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/unitTests/renderer/ReflectionRefractionTests.java b/unitTests/renderer/ReflectionRefractionTests.java
new file mode 100644
--- /dev/null	(date 1684093868342)
+++ b/unitTests/renderer/ReflectionRefractionTests.java	(date 1684093868342)
@@ -0,0 +1,107 @@
+/**
+ *
+ */
+package renderer;
+
+import static java.awt.Color.*;
+
+import org.junit.jupiter.api.Test;
+
+import geometries.Sphere;
+import geometries.Triangle;
+import lighting.AmbientLight;
+import lighting.SpotLight;
+import primitives.*;
+import renderer.*;
+import scene.Scene;
+
+/** Tests for reflection and transparency functionality, test for partial
+ * shadows
+ * (with transparency)
+ * @author dzilb */
+public class ReflectionRefractionTests {
+    private Scene scene = new Scene.SceneBuilder("Test scene").build();
+
+    /** Produce a picture of a sphere lighted by a spot light */
+    @Test
+    public void twoSpheres() {
+        Camera camera = new Camera(new Point(0, 0, 1000), new Vector(0, 0, -1), new Vector(0, 1, 0)) //
+                .setVPSize(150, 150).setVPDistance(1000);
+
+        scene.getGeometries().add( //
+                new Sphere(new Point(0, 0, -50), 50d).setEmission(new Color(BLUE)) //
+                        .setMaterial(new Material().setKd(0.4).setKs(0.3).setShininess(100).setKt(0.3)),
+                new Sphere(new Point(0, 0, -50), 25d).setEmission(new Color(RED)) //
+                        .setMaterial(new Material().setKd(0.5).setKs(0.5).setShininess(100)));
+        scene.getLights().add( //
+                new SpotLight(new Color(1000, 600, 0), new Point(-100, -100, 500), new Vector(-1, -1, -2)) //
+                        .setKl(0.0004).setKq(0.0000006));
+
+        camera.setImageWriter(new ImageWriter("refractionTwoSpheres", 500, 500)) //
+                .setRayTracer(new RayTracerBasic(scene)) //
+                .renderImage() //
+                .writeToImage();
+    }
+
+    /** Produce a picture of a sphere lighted by a spot light */
+    @Test
+    public void twoSpheresOnMirrors() throws IllegalAccessException {
+        Camera camera = new Camera(new Point(0, 0, 10000), new Vector(0, 0, -1), new Vector(0, 1, 0)) //
+                .setVPSize(2500, 2500).setVPDistance(10000); //
+
+        scene.setAmbientLight(new AmbientLight(new Color(255, 255, 255), 0.1));
+
+        scene.getGeometries().add( //
+                new Sphere(new Point(-950, -900, -1000), 400d).setEmission(new Color(0, 50, 100)) //
+                        .setMaterial(new Material().setKd(0.25).setKs(0.25).setShininess(20)
+                                .setKt(new Double3(0.5, 0, 0))),
+                new Sphere(new Point(-950, -900, -1000), 200d).setEmission(new Color(100, 50, 20)) //
+                        .setMaterial(new Material().setKd(0.25).setKs(0.25).setShininess(20)),
+                new Triangle(new Point(1500, -1500, -1500), new Point(-1500, 1500, -1500),
+                        new Point(670, 670, 3000)) //
+                        .setEmission(new Color(20, 20, 20)) //
+                        .setMaterial(new Material().setKr(1)),
+                new Triangle(new Point(1500, -1500, -1500), new Point(-1500, 1500, -1500),
+                        new Point(-1500, -1500, -2000)) //
+                        .setEmission(new Color(20, 20, 20)) //
+                        .setMaterial(new Material().setKr(new Double3(0.5, 0, 0.4))));
+
+        scene.getLights().add(new SpotLight(new Color(1020, 400, 400), new Point(-750, -750, -150), new Vector(-1, -1, -4)) //
+                .setKl(0.00001).setKq(0.000005));
+
+        ImageWriter imageWriter = new ImageWriter("reflectionTwoSpheresMirrored", 500, 500);
+        camera.setImageWriter(imageWriter) //
+                .setRayTracer(new RayTracerBasic(scene)) //
+                .renderImage() //
+                .writeToImage();
+    }
+
+    /** Produce a picture of a two triangles lighted by a spot light with a
+     * partially
+     * transparent Sphere producing partial shadow */
+    @Test
+    public void trianglesTransparentSphere() throws IllegalAccessException {
+        Camera camera = new Camera(new Point(0, 0, 1000), new Vector(0, 0, -1), new Vector(0, 1, 0)) //
+                .setVPSize(200, 200).setVPDistance(1000);
+
+        scene.setAmbientLight(new AmbientLight(new Color(WHITE), 0.15));
+
+        scene.getGeometries().add( //
+                new Triangle(new Point(-150, -150, -115), new Point(150, -150, -135),
+                        new Point(75, 75, -150)) //
+                        .setMaterial(new Material().setKd(0.5).setKs(0.5).setShininess(60)), //
+                new Triangle(new Point(-150, -150, -115), new Point(-70, 70, -140), new Point(75, 75, -150)) //
+                        .setMaterial(new Material().setKd(0.5).setKs(0.5).setShininess(60)), //
+                new Sphere(new Point(60, 50, -50), 30d).setEmission(new Color(BLUE)) //
+                        .setMaterial(new Material().setKd(0.2).setKs(0.2).setShininess(30).setKt(0.6)));
+
+        scene.getLights().add(new SpotLight(new Color(700, 400, 400), new Point(60, 50, 0), new Vector(0, 0, -1)) //
+                .setKl(4E-5).setKq(2E-7));
+
+        ImageWriter imageWriter = new ImageWriter("refractionShadow", 600, 600);
+        camera.setImageWriter(imageWriter) //
+                .setRayTracer(new RayTracerBasic(scene)) //
+                .renderImage() //
+                .writeToImage();
+    }
+}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"cd85df16-315c-4a3a-a242-2e29245d113c\" name=\"Changes\" comment=\"end of lighting and tests\">\r\n      <change afterPath=\"$PROJECT_DIR$/unitTests/renderer/ShadowTests.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_21_[Changes]/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_21__Changes_.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_57_[Changes]/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_57__Changes_.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_14_35_[Changes]/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_14_35__Changes_.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Cylinder.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Cylinder.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Geometries.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Geometries.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Intersectable.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Intersectable.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Plane.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Plane.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Polygon.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Polygon.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Sphere.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Sphere.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Triangle.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Triangle.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/geometries/Tube.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/geometries/Tube.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/lighting/DirectionalLight.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/lighting/DirectionalLight.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/lighting/LightSource.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/lighting/LightSource.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/lighting/PointLight.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/lighting/PointLight.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/primitives/Material.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/primitives/Material.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/primitives/Ray.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/primitives/Ray.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/renderer/RayTracerBasic.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/renderer/RayTracerBasic.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/unitTests/geometries/SphereTest.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/unitTests/geometries/SphereTest.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/unitTests/lighting/LightsTests.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/unitTests/lighting/LightsTests.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Interface\" />\r\n        <option value=\"JUnit5 Test Class\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"PUSH_TAGS\">\r\n      <GitPushTagMode>\r\n        <option name=\"argument\" value=\"--tags\" />\r\n        <option name=\"title\" value=\"All\" />\r\n      </GitPushTagMode>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2OV7lVSK63W6tEIpxe8AW34Ehsg\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;true&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary&quot;: &quot;JUnit5&quot;,\r\n    &quot;com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5&quot;: &quot;&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/kayma/Downloads/ISE_5783_0586_5404/unitTests/renderer&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;fileTemplates&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\kayma\\Downloads\\ISE_5783_0586_5404\\unitTests\\renderer\" />\r\n    </key>\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\kayma\\Downloads\\ISE_5783_0586_5404\\unitTests\\renderer\" />\r\n      <recent name=\"C:\\Users\\Haim\\IdeaProjects\\ISE_5783_0586_5404\\unitTests\" />\r\n      <recent name=\"C:\\Users\\Haim\\IdeaProjects\\ISE_5783_0586_5404\\src\" />\r\n    </key>\r\n    <key name=\"CreateTestDialog.Recents.Supers\">\r\n      <recent name=\"\" />\r\n    </key>\r\n    <key name=\"CreateTestDialog.RecentsKey\">\r\n      <recent name=\"primitives\" />\r\n      <recent name=\"renderer\" />\r\n      <recent name=\"geometries\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"JUnit.ShadowTests\">\r\n    <configuration name=\"LightsTests\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ISE_5783_0586_5404\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"lighting.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"PACKAGE_NAME\" value=\"lighting\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"lighting.LightsTests\" />\r\n      <option name=\"TEST_OBJECT\" value=\"class\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"PlaneTest.testFindIntersections\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ISE_5783_0586_5404\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"geometries.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"PACKAGE_NAME\" value=\"geometries\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"geometries.PlaneTest\" />\r\n      <option name=\"METHOD_NAME\" value=\"testFindIntersections\" />\r\n      <option name=\"TEST_OBJECT\" value=\"method\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"PolygonTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ISE_5783_0586_5404\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"geometries.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"PACKAGE_NAME\" value=\"geometries\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"geometries.PolygonTest\" />\r\n      <option name=\"TEST_OBJECT\" value=\"class\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"ShadowTests\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ISE_5783_0586_5404\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"renderer.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"PACKAGE_NAME\" value=\"renderer\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"renderer.ShadowTests\" />\r\n      <option name=\"TEST_OBJECT\" value=\"class\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"TubeTest.testFindIntersections\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"ISE_5783_0586_5404\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"geometries.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"PACKAGE_NAME\" value=\"geometries\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"geometries.TubeTest\" />\r\n      <option name=\"METHOD_NAME\" value=\"testFindIntersections\" />\r\n      <option name=\"TEST_OBJECT\" value=\"method\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"JUnit.ShadowTests\" />\r\n        <item itemvalue=\"JUnit.LightsTests\" />\r\n        <item itemvalue=\"JUnit.TubeTest.testFindIntersections\" />\r\n        <item itemvalue=\"JUnit.PolygonTest\" />\r\n        <item itemvalue=\"JUnit.PlaneTest.testFindIntersections\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"cd85df16-315c-4a3a-a242-2e29245d113c\" name=\"Changes\" comment=\"\" />\r\n      <created>1681634049579</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1681634049579</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"stage 0\">\r\n      <created>1681634213332</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1681634213332</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"stage 0\">\r\n      <created>1681634412653</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1681634412653</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"sof sof stage 1\">\r\n      <created>1681634845568</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1681634845568</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Intersectable\">\r\n      <created>1681826245666</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1681826245666</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"unit tests for findIntersections finished besides Tube\">\r\n      <created>1682251398631</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682251398631</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"stage 3 tag\">\r\n      <created>1682251555241</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682251555241</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"beginning of camera\">\r\n      <created>1682423296985</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682423296985</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\" with integrations tests\">\r\n      <created>1682843187972</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682843187973</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"end of stage 4- integration tests and fixed sphere intersection\">\r\n      <created>1682963809711</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1682963809711</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"tag for stage 4\">\r\n      <created>1683012264480</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1683012264480</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"part 4 of stage 5 in the process\">\r\n      <created>1683128188572</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1683128188572</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"part 4 of stage 5 - test of image in process\">\r\n      <created>1683444043485</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1683444043485</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"cast ray\">\r\n      <created>1683446244035</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1683446244035</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"end of lighting and tests\">\r\n      <created>1684049383754</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1684049383754</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"15\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\r\n    <MESSAGE value=\"stage 0\" />\r\n    <MESSAGE value=\"sof sof stage 1\" />\r\n    <MESSAGE value=\"Intersectable\" />\r\n    <MESSAGE value=\"unit tests for findIntersections finished besides Tube\" />\r\n    <MESSAGE value=\"stage 3 tag\" />\r\n    <MESSAGE value=\"beginning of camera\" />\r\n    <MESSAGE value=\" with integrations tests\" />\r\n    <MESSAGE value=\"end of stage 4- integration tests and fixed sphere intersection\" />\r\n    <MESSAGE value=\"tag for stage 4\" />\r\n    <MESSAGE value=\"part 4 of stage 5 in the process\" />\r\n    <MESSAGE value=\"part 4 of stage 5 - test of image in process\" />\r\n    <MESSAGE value=\"cast ray\" />\r\n    <MESSAGE value=\"end of lighting and tests\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"end of lighting and tests\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 5f2d62ab7c15a61ddcdf70a4c4164443f7040c90)
+++ b/.idea/workspace.xml	(date 1684176494919)
@@ -4,31 +4,12 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="cd85df16-315c-4a3a-a242-2e29245d113c" name="Changes" comment="end of lighting and tests">
-      <change afterPath="$PROJECT_DIR$/unitTests/renderer/ShadowTests.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_21_[Changes]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_21__Changes_.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_57_[Changes]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_10_57__Changes_.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_14_35_[Changes]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_07_05_2023_14_35__Changes_.xml" beforeDir="false" />
+    <list default="true" id="cd85df16-315c-4a3a-a242-2e29245d113c" name="Changes" comment="end of shadowing">
+      <change afterPath="$PROJECT_DIR$/src/ReadXml.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/unitTests/renderer/ReflectionRefractionTests.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Cylinder.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Cylinder.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Geometries.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Geometries.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Intersectable.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Intersectable.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Plane.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Plane.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Polygon.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Polygon.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Sphere.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Sphere.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Triangle.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Triangle.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/geometries/Tube.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/geometries/Tube.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/lighting/DirectionalLight.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/lighting/DirectionalLight.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/lighting/LightSource.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/lighting/LightSource.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/lighting/PointLight.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/lighting/PointLight.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/primitives/Material.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/primitives/Material.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/primitives/Ray.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/primitives/Ray.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/renderer/RayTracerBasic.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/renderer/RayTracerBasic.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/unitTests/geometries/SphereTest.java" beforeDir="false" afterPath="$PROJECT_DIR$/unitTests/geometries/SphereTest.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/unitTests/lighting/LightsTests.java" beforeDir="false" afterPath="$PROJECT_DIR$/unitTests/lighting/LightsTests.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/scene/Scene.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/scene/Scene.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -100,7 +81,7 @@
       <recent name="geometries" />
     </key>
   </component>
-  <component name="RunManager" selected="JUnit.ShadowTests">
+  <component name="RunManager" selected="JUnit.ReflectionRefractionTests">
     <configuration name="LightsTests" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="ISE_5783_0586_5404" />
       <extension name="coverage">
@@ -116,7 +97,7 @@
         <option name="Make" enabled="true" />
       </method>
     </configuration>
-    <configuration name="PlaneTest.testFindIntersections" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+    <configuration name="PolygonTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="ISE_5783_0586_5404" />
       <extension name="coverage">
         <pattern>
@@ -125,23 +106,22 @@
         </pattern>
       </extension>
       <option name="PACKAGE_NAME" value="geometries" />
-      <option name="MAIN_CLASS_NAME" value="geometries.PlaneTest" />
-      <option name="METHOD_NAME" value="testFindIntersections" />
-      <option name="TEST_OBJECT" value="method" />
+      <option name="MAIN_CLASS_NAME" value="geometries.PolygonTest" />
+      <option name="TEST_OBJECT" value="class" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
-    <configuration name="PolygonTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+    <configuration name="ReflectionRefractionTests" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="ISE_5783_0586_5404" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="geometries.*" />
+          <option name="PATTERN" value="renderer.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="PACKAGE_NAME" value="geometries" />
-      <option name="MAIN_CLASS_NAME" value="geometries.PolygonTest" />
+      <option name="PACKAGE_NAME" value="renderer" />
+      <option name="MAIN_CLASS_NAME" value="renderer.ReflectionRefractionTests" />
       <option name="TEST_OBJECT" value="class" />
       <method v="2">
         <option name="Make" enabled="true" />
@@ -180,11 +160,11 @@
     </configuration>
     <recent_temporary>
       <list>
+        <item itemvalue="JUnit.ReflectionRefractionTests" />
+        <item itemvalue="JUnit.LightsTests" />
         <item itemvalue="JUnit.ShadowTests" />
-        <item itemvalue="JUnit.LightsTests" />
         <item itemvalue="JUnit.TubeTest.testFindIntersections" />
         <item itemvalue="JUnit.PolygonTest" />
-        <item itemvalue="JUnit.PlaneTest.testFindIntersections" />
       </list>
     </recent_temporary>
   </component>
@@ -295,7 +275,14 @@
       <option name="project" value="LOCAL" />
       <updated>1684049383754</updated>
     </task>
-    <option name="localTasksCounter" value="15" />
+    <task id="LOCAL-00015" summary="end of shadowing">
+      <created>1684092908386</created>
+      <option name="number" value="00015" />
+      <option name="presentableId" value="LOCAL-00015" />
+      <option name="project" value="LOCAL" />
+      <updated>1684092908386</updated>
+    </task>
+    <option name="localTasksCounter" value="16" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -324,6 +311,7 @@
     <MESSAGE value="part 4 of stage 5 - test of image in process" />
     <MESSAGE value="cast ray" />
     <MESSAGE value="end of lighting and tests" />
-    <option name="LAST_COMMIT_MESSAGE" value="end of lighting and tests" />
+    <MESSAGE value="end of shadowing" />
+    <option name="LAST_COMMIT_MESSAGE" value="end of shadowing" />
   </component>
 </project>
\ No newline at end of file
Index: src/ReadXml.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ReadXml.java b/src/ReadXml.java
new file mode 100644
--- /dev/null	(date 1684176494530)
+++ b/src/ReadXml.java	(date 1684176494530)
@@ -0,0 +1,201 @@
+
+
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.ParserConfigurationException;
+
+import geometries.*;
+import org.w3c.dom.Document;
+import org.w3c.dom.NodeList;
+import org.w3c.dom.Node;
+import org.w3c.dom.Element;
+import org.xml.sax.SAXException;
+import lighting.AmbientLight;
+import primitives.Color;
+import primitives.Double3;
+import primitives.Point;
+import primitives.Vector;
+import scene.Scene;
+import java.io.File;
+import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class ReadXml {
+
+
+
+    /**
+     * the function get a file name in xml, read it and make a scene from the data
+     * @param scene_Name the scene name
+     * @param file_name the xml file name
+     * @return the scene of the file
+     */
+    public static Scene ReadFile(String scene_Name, String file_name) {
+
+        Scene scene = new Scene.SceneBuilder(scene_Name).build();
+        File xmlFile = new File(file_name);
+
+        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
+        DocumentBuilder dBuilder;
+        try {
+
+            dBuilder = dbFactory.newDocumentBuilder();
+            Document doc = dBuilder.parse(xmlFile);
+            doc.getDocumentElement().normalize();
+            Element node = doc.getDocumentElement();
+
+            //get the background color and set in the scene
+            Point backColor = parsePoint(node.getAttribute("background-color"));
+            Color Cb = new Color(backColor.getX(), backColor.getY(), backColor.getZ());
+            scene.setBackground(Cb);
+
+            //get the ambient light color and set in the scene
+            Point ambientColor = parsePoint(((Element) doc.getElementsByTagName("ambient-light").item(0)).getAttribute("color"));
+            Color Ca = new Color(ambientColor.getX(), ambientColor.getY(), ambientColor.getZ());
+            scene.setAmbientLight(new AmbientLight(Ca, new Double3(1,1,1)));
+
+            //new geometries for the scene
+            Geometries geoList = new Geometries();
+
+            //get all the triangle
+            NodeList nodeList = doc.getElementsByTagName("triangle");
+            for (int i = 0; i < nodeList.getLength(); i++) {
+                geoList.add(getTriangle(nodeList.item(i)));
+            }
+            //get all the Polygon
+            nodeList = doc.getElementsByTagName("polygon");
+            for (int i = 0; i < nodeList.getLength(); i++) {
+                geoList.add(getPolygon(nodeList.item(i)));
+            }
+
+            //get all the sphere
+            nodeList = doc.getElementsByTagName("sphere");
+            for (int i = 0; i < nodeList.getLength(); i++) {
+                geoList.add(getSphere(nodeList.item(i)));
+            }
+            //get all the plane
+            nodeList = doc.getElementsByTagName("plane");
+            for (int i = 0; i < nodeList.getLength(); i++) {
+                geoList.add(getPlane(nodeList.item(i)));
+            }
+
+            //set the geometries in the scene
+            scene.setGeometries(geoList);
+
+        }
+        catch (SAXException | ParserConfigurationException | IOException e1) {
+            e1.printStackTrace();
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+
+        return scene;
+    }
+
+    /**
+     * the function create a triangle from the node
+     * @param node
+     * @return Triangle
+     */
+    private static Triangle getTriangle(Node node) throws IllegalAccessException {
+
+        Triangle geo = null;
+        if (node.getNodeType() == Node.ELEMENT_NODE) {
+            Element element = (Element) node;
+            Point p0 = parsePoint(((Element) node).getAttribute("p0"));
+            Point p1 = parsePoint(((Element) node).getAttribute("p1"));
+            Point p2 = parsePoint(((Element) node).getAttribute("p2"));
+            geo = new Triangle(p0, p1, p2);
+        }
+        return geo;
+    }
+
+
+    /**
+     * the function create a sphere from the node
+     * @param node
+     * @return Sphere
+     */
+    private static Sphere getSphere(Node node) {
+
+        Sphere geo=null;
+        if (node.getNodeType() == Node.ELEMENT_NODE) {
+
+            Element element = (Element) node;
+            Point p0 = parsePoint(((Element) node).getAttribute("center"));
+            int r= Integer.parseInt( ((Element) node).getAttribute("radius"));
+            geo=new Sphere(p0,r);
+        }
+        return geo;
+    }
+
+    /**
+     * the function create a Plane from the node
+     * @param node
+     * @return Plane
+     */
+    private static Plane getPlane(Node node) {
+
+        Plane geo=null;
+        if (node.getNodeType() == Node.ELEMENT_NODE) {
+
+            Element element = (Element) node;
+            Point p0 = parsePoint(((Element) node).getAttribute("p0"));
+            Point v0 = parsePoint(((Element) node).getAttribute("vector"));
+            Vector v=new Vector(v0.getX(),v0.getY(),v0.getZ());
+            geo=new Plane(p0,v);
+        }
+        return geo;
+    }
+
+    /**
+     * the function create a Polygon from the node
+     * @param node
+     * @return Polygon
+     */
+    private static Polygon getPolygon(Node node) throws IllegalAccessException {
+
+        Polygon geo=null;
+        Point[] arr=null;
+        if (node.getNodeType() == Node.ELEMENT_NODE) {
+            Element element = (Element) node;
+            int len=node.getAttributes().getLength();
+            arr=new Point[len];
+            //  var points=node.getAttributes();
+            for (int i=0;i<len;i++)
+            {
+                Point p0 = parsePoint(((Element) node).getAttribute("p"+i));
+                arr[i]=p0;
+            }
+            geo=new Polygon(arr);
+        }
+        return geo;
+    }
+
+    private static String getTagValue(String tag, Element element) {
+        NodeList nodeList = element.getElementsByTagName(tag).item(0).getChildNodes();
+        Node node = (Node) nodeList.item(0);
+        return node.getNodeValue();
+    }
+
+    /**
+     * the function return point from string point
+     * @param s string
+     * @return Point
+     */
+    public static Point parsePoint(String s) {
+
+        Pattern p = Pattern.compile("-?\\d+");
+        Matcher m = p.matcher(s);
+        int[] arr = new int[3];
+        int i = 0;
+
+        while (m.find()) {
+            arr[i++] = Integer.parseInt(m.group());
+        }
+        return new Point(arr[0], arr[1], arr[2]);
+    }
+}
+
+
